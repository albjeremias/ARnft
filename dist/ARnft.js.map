{"version":3,"file":"ARnft.js","sources":["../src/core/NFTWorker.ts","../src/core/NFTEntity.ts","../src/ARnftCore.ts","../src/core/components/ARControllerComponent.ts","../src/core/renderers/CameraViewRenderer.ts","../src/ARnft.ts","../src/core/ARUtils.ts"],"sourcesContent":["//import { ARnft } from \"../ARnft\";\nimport { NFTEntity } from \"./NFTEntity\";\nimport Worker from 'web-worker:./ARnftWorker.ts';\n\nexport class NFTOrientation {\n    // euler vector3\n    public position: IterableIterator<number>;\n    // qauaterion\n    public rotation: IterableIterator<number>;\n\n    public matrix: IterableIterator<number>;\n}\n\nexport class NFTWorker {\n\n    private _dispatcher: NFTEntity;\n\n    private worker: Worker;\n\n    private markerURL: any;\n\n    private _processing: boolean = false;\n\n    private vw: number;\n    private vh: number;\n\n    constructor(d: NFTEntity, markerURL: string, w: number, h: number) {\n        this._dispatcher = d;\n        this.markerURL = markerURL;\n        this.vw = w;\n        this.vh = h;\n    }\n\n    public initialize(cameraURL: string): Promise<boolean> {\n        return new Promise<boolean>((resolve, reject) => {\n            this.worker = new Worker();\n            //this.worker.onmessage = (ev) => {\n                this.load(cameraURL).then(() => {\n                    // Overwrite load onmessage with search onmessage\n                    /*this.worker.onmessage = (ev) => {\n\n                        // console.log(\"response found = \" + (ev.data.type == \"found\"));\n                        let msg: any = (ev.data.type == \"found\") ? ev.data : null;\n                        this._dispatcher.found(msg);\n                        this._processing = false;\n                    };*/\n                    //\n                    resolve(true);\n                });\n            //};\n\n        });\n    }\n\n    public process(imageData: ImageData) {\n\n        if (this._processing) {\n            return;\n        }\n        this._processing = true;\n\n        //this.worker.postMessage({ type: 'process', imagedata: imageData }, [imageData.data.buffer]);\n        this.worker.postMessage({ type: 'process', imagedata: imageData });\n    }\n\n    protected load(cameraURL: string): Promise<boolean> {\n\n        return new Promise<boolean>((resolve, reject) => {\n\n            var pscale = 320 / Math.max(this.vw, this.vh / 3 * 4);\n\n            let w: number = this.vw * pscale;\n            let h: number = this.vh * pscale;\n            let pw: number = Math.max(w, (h / 3) * 4);\n            let ph: number = Math.max(h, (w / 4) * 3);\n\n            this.worker.postMessage({\n                type: 'load',\n                pw: pw,\n                ph: ph,\n                camera_para: cameraURL,\n                marker: this.markerURL\n            });\n\n            this.worker.onmessage = (ev) => {\n                var msg = ev.data;\n                switch (msg.type) {\n                    case 'loaded': {\n                        var proj = JSON.parse(msg.proj);\n                        // this._dispatcher.dispatchEvent(new CustomEvent(ARnft.EVENT_SET_CAMERA, proj));\n                        break;\n                    }\n                    case \"endLoading\": {\n                        if (msg.end == true)\n                            resolve(true);\n                        break;\n                    }\n                }\n                this._processing = false;\n            };\n        });\n    };\n\n    public destroy(): void {\n\n    }\n\n}","import { NFTOrientation, NFTWorker } from \"./NFTWorker\";\n\nexport interface IMediaNode {\n    update(): void;\n    found(value: NFTOrientation): void;\n}\n\nexport interface INFTEntity {\n    update(): void;\n    found(msg: NFTOrientation): void;\n    initialize(cameraData: string): Promise<boolean>;\n    process(imageData: ImageData): void;\n    destroy(): void;\n}\n\nexport class NFTEntity implements INFTEntity {\n\n\n    private _nodes: IMediaNode[] = [];\n\n    private _worker: NFTWorker;\n\n    private _cameraURL: string;\n\n    protected orientationMatrix: any;\n\n    protected _markerURL: string;\n\n    constructor(node: IMediaNode, markerURL: string, w: number, h: number) {\n        this._markerURL = markerURL;\n        this._worker = new NFTWorker(this, this._markerURL, w, h);\n\n        this._nodes.push(node);\n    }\n\n    public initialize(cameraData: string): Promise<boolean> {\n        this._cameraURL = cameraData;\n        return this._worker.initialize(this._cameraURL);\n    }\n\n    public found(msg: NFTOrientation): void {\n        // this.orientationMatrix = (msg) ? JSON.parse(msg.matrixGL_RH) : null;\n        this._nodes.forEach(element => {\n            element.found(msg);\n        });\n    }\n\n    public process(imageData: ImageData): void {\n        this._worker.process(imageData);\n    }\n\n    public update(): void {\n        //  loop through nodes and update\n        this._nodes.forEach(element => {\n            element.update();\n        });\n    }\n\n    public destroy(): void {\n\n    }\n}\n","import { NFTEntity, INFTEntity, IMediaNode } from \"./core/NFTEntity\";\nimport { ICameraViewRenderer } from \"./core/renderers/CameraViewRenderer\";\nimport { AppJson } from \"./core/data/AppData\";\n\nexport class ARnftCore {\n\n    private count: number = 0;\n\n    private _controllers: Map<string, INFTEntity> = new Map<string, INFTEntity>();\n\n    private _videoRenderer: ICameraViewRenderer;\n\n    private _cameraDataURL: string;\n\n    private _fps: number = 15;\n\n    private _lastTime: number = 0;\n\n    public appData: AppJson;\n\n    // events\n    public static readonly EVENT_SET_CAMERA: string = \"ARNFT_SET_CAMERA_EVENT\";\n    public static readonly EVENT_FOUND_MARKER: string = \"ARNFT_FOUND_MARKER_EVENT\";\n    public static readonly EVENT_LOST_MARKER: string = \"ARNFT_LOST_MARKER_EVENT\";\n\n    constructor(video: ICameraViewRenderer, camData: string) {\n        this._videoRenderer = video;\n        this._cameraDataURL = camData;\n        // set default fps at 15\n        this.setFPS(this._fps);\n    }\n\n    public addNFTEntity(entity: INFTEntity, name?: string): INFTEntity {\n\n        if (!name)\n            name = \"entity-\" + this.count++;\n\n        this._controllers.set(name, entity);\n        return entity;\n    }\n\n    public addNFTEntity2(node: IMediaNode, markerUrl: string, name?: string) {\n\n        if (!name)\n            name = \"entity-\" + this.count++;\n    \n        let entity = new NFTEntity(node, markerUrl, 120, 120);\n\n        this._controllers.set(name, entity);\n    }\n\n    public getEntityByName(name: string): INFTEntity {\n        if (!this._controllers.has(name))\n            return null;\n\n        return this._controllers.get(name);\n    }\n\n    public getCameraView(): ICameraViewRenderer {\n        return this._videoRenderer;\n    }\n\n    public setFPS(value: number): void {\n        this._fps = 1000 / value;\n    }\n\n    public initialize(): Promise<boolean> {\n        console.log(\"init ARnft\");\n\n        let promises: Promise<boolean>[] = [];\n        this._controllers.forEach(element => {\n            promises.push(element.initialize(this._cameraDataURL));\n        });\n\n        return Promise.all(promises).then(() => {\n            return true;\n        });\n    }\n\n    public update(): void {\n        let time: number = Date.now();\n        let imageData: ImageData;\n        if ((time - this._lastTime) > this._fps) {\n            imageData = this._videoRenderer.getImage();\n            console.log(imageData);\n            \n            this._lastTime = time;\n        }\n\n        this._controllers.forEach(element => {\n            element.update();\n            if (imageData)\n                element.process(imageData);\n        });\n    }\n\n    public destroy(): void {\n        this._controllers.forEach(entity => {\n            entity.destroy();\n        });\n        this._controllers.clear();\n        this._videoRenderer = null;\n    }\n}\n","import { IMediaNode } from '../NFTEntity';\n\nexport class ARControllerComponent implements IMediaNode{\n\n    protected world: any;\n    private _hasFound: boolean = false;\n    private _frameDrops: number = 0;\n\n    constructor() {}\n    public update(){\n        if (!this.world) {\n            this._hasFound = false;\n            this._frameDrops = 0;\n        } else {}\n    }\n\n    public found(msg: any): void {\n\n    this.world = msg;\n    }\n}","\nexport interface VideoSettingData {\n    width: ScreenData;\n    height: ScreenData;\n    facingMode: string;\n}\n\nexport interface ScreenData {\n    min: number;\n    max: number;\n}\n\nexport interface ICameraViewRenderer {\n    getHeight(): number;\n    getWidth(): number;\n    getImage(): ImageData;\n}\n\nexport class CameraViewRenderer implements ICameraViewRenderer {\n\n    private canvas_process: HTMLCanvasElement;\n\n    private context_process: CanvasRenderingContext2D;\n\n    public video: HTMLVideoElement;\n\n    private _facing: string;\n\n    private vw: number;\n    private vh: number;\n\n    private w: number;\n    private h: number;\n\n    private pw: number;\n    private ph: number;\n\n    private ox: number;\n    private oy: number;\n\n    constructor(video: HTMLVideoElement) {\n        this.canvas_process = document.createElement('canvas');\n        this.context_process = this.canvas_process.getContext('2d');\n        this.video = video;\n    }\n\n    public getHeight(): number {\n        return this.vh;\n    }\n\n    public getWidth(): number {\n        return this.vw;\n    }\n\n    public getImage(): ImageData {\n        this.context_process.drawImage(this.video, 0, 0, this.vw, this.vh, this.ox, this.oy, this.w, this.h);\n        return this.context_process.getImageData(0, 0, this.pw, this.ph);\n    }\n\n    public initialize(videoSettings: VideoSettingData): Promise<boolean> {\n\n        this._facing = videoSettings.facingMode || 'environment'\n\n        const constraints = {}\n        const mediaDevicesConstraints = {}\n\n        return new Promise<boolean>(async (resolve, reject) => {\n            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n                var hint: any = {\n                    \"audio\": false,\n                    \"video\": {\n                        facingMode: this._facing,\n                        width: { min: 480, max: 640 }\n                    }\n                };\n\n                navigator.mediaDevices.getUserMedia(hint).then(async (stream) => {\n                    this.video.srcObject = stream;\n                    this.video = await new Promise<HTMLVideoElement>((resolve, reject) => {\n                        this.video.onloadedmetadata = () => resolve(this.video);\n                    }).then((value) => {\n\n                        this.vw = this.video.videoWidth;\n                        this.vh = this.video.videoHeight;\n\n                        var pscale = 320 / Math.max(this.vw, this.vh / 3 * 4);\n\n                        this.w = this.vw * pscale;\n                        this.h = this.vh * pscale;\n                        this.pw = Math.max(this.w, (this.h / 3) * 4);\n                        this.ph = Math.max(this.h, (this.w / 4) * 3);\n                        this.ox = (this.pw - this.w) / 2;\n                        this.oy = (this.ph - this.h) / 2;\n\n                        this.canvas_process.width = this.pw;\n                        this.canvas_process.height = this.ph;\n\n                        this.context_process.fillStyle = 'black';\n                        this.context_process.fillRect(0, 0, this.pw, this.ph);\n                        resolve(true);\n                        return value;\n                    }).catch((msg) => {\n                        console.log(msg);\n                        reject(msg);\n                        return null;\n                    });\n                }).catch((error) => {\n                    console.error(error);\n                    reject(error);\n                });\n            }\n            else {\n                // reject(\"No navigator.mediaDevices && navigator.mediaDevices.getUserMedia\");\n                reject(\"Sorry, Your device does not support this experince.\");\n            }\n        });\n    }\n}","import { ARnftCore } from './ARnftCore'\nimport { NFTEntity, INFTEntity, IMediaNode } from \"./core/NFTEntity\";\nimport { ARControllerComponent } from \"./core/components/ARControllerComponent\"\nimport { AppJson } from \"./core/data/AppData\";\nimport { CameraViewRenderer } from \"./core/renderers/CameraViewRenderer\";\nimport { getConfig } from \"./core/ARUtils\";\n\nexport class ARnft {\n    public cameraView: CameraViewRenderer;\n    public appData: AppJson;\n    public configUrl: string;\n    public markerUrl: string;\n    private _arnftCore: ARnftCore;\n    public camData: string;\n    constructor(configUrl: string, camUrl: string, markerUrl: string){\n        this.camData = camUrl;\n        this.configUrl = configUrl;\n        this.markerUrl = markerUrl;\n    }\n\n    public async initialize(): Promise<boolean> {\n\n        getConfig(this.configUrl);\n        document.addEventListener('getConfig', async (ev: any) => {\n            this.appData = ev.detail.config;\n            console.log(this.appData);\n        // views\n        this.cameraView = new CameraViewRenderer(document.getElementById(\"video\") as HTMLVideoElement);\n        await this.cameraView.initialize(this.appData.videoSettings).catch((error) => {\n            console.error(error);\n            return Promise.reject(false);\n        });\n\n        this._arnftCore = new ARnftCore(this.cameraView, this.camData);\n        await this._arnftCore.initialize().catch((error: any) => {\n            console.error(error);\n            return Promise.reject(false);\n        })\n\n        let arComponent: ARControllerComponent = new ARControllerComponent();\n\n        let nftEntity: NFTEntity = new NFTEntity(arComponent,this.markerUrl, 200, 200);\n        await nftEntity.initialize(this.camData);\n        this._arnftCore.addNFTEntity(nftEntity);\n        this._arnftCore.update();\n    })\n        return Promise.resolve(true);\n    }\n\n    public createEntity(cameraData: string, markerUrl: string, w: number, h: number) {\n        //let nftEntity: NFTEntity = new NFTEntity(markerUrl, w, h);\n        //return nftEntity;\n    }\n\n    public addNFTEntity(entity: INFTEntity, name?: string): INFTEntity {\n        return this._arnftCore.addNFTEntity(entity, name);\n    }\n\n    private update(): void {\n        console.log(this._arnftCore);\n        \n        this._arnftCore.update();\n    }\n}","export function degreesToRadians(degrees: number): number {\n    return degrees * (Math.PI / 180);\n}\n\nexport function isMobile(): boolean {\n    //return /Android|mobile|iPad|iPhone/i.test(navigator.userAgent)\n    if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {\n        // true for mobile device\n        return true;\n    }\n    return false;\n}\nexport function isIOS(): boolean {\n    if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {\n        // true for mobile device\n        return true;\n    }\n    return false;\n}\n \n export function getConfig(configData: string): boolean {\n  fetch(configData)\n   .then(response => {\n       if (!response.ok) {\n         throw new Error(\"HTTP error, status = \" + response.status);\n       }\n       return response.json();\n     })\n     .then((response) => {\n       // printing the response only for testing\n       console.log(response);\n       const eventData = new CustomEvent('getConfig', { detail: { config: response } });\n       document.dispatchEvent(eventData);\n       return(response)\n     })\n     .catch(function(error) {\n         console.error(error);\n         return Promise.reject(false);\n       });\n   return true;\n }\n \n"],"names":["NFTWorker","[object Object]","d","markerURL","w","h","this","_dispatcher","vw","vh","cameraURL","Promise","resolve","reject","worker","Worker","load","then","imageData","_processing","postMessage","type","imagedata","pscale","Math","max","pw","ph","camera_para","marker","onmessage","ev","msg","data","JSON","parse","proj","end","NFTEntity","node","_markerURL","_worker","_nodes","push","cameraData","_cameraURL","initialize","forEach","element","found","process","update","ARnftCore","video","camData","Map","_videoRenderer","_cameraDataURL","setFPS","_fps","entity","name","count","_controllers","set","markerUrl","has","get","value","console","log","promises","all","time","Date","now","_lastTime","getImage","destroy","clear","ARControllerComponent","world","_hasFound","_frameDrops","CameraViewRenderer","canvas_process","document","createElement","context_process","getContext","drawImage","ox","oy","getImageData","videoSettings","_facing","facingMode","async","navigator","mediaDevices","getUserMedia","hint","audio","width","min","stream","srcObject","onloadedmetadata","videoWidth","videoHeight","height","fillStyle","fillRect","catch","error","configUrl","camUrl","configData","fetch","response","ok","Error","status","json","eventData","CustomEvent","detail","config","dispatchEvent","addEventListener","appData","cameraView","getElementById","_arnftCore","arComponent","nftEntity","addNFTEntity"],"mappings":"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"}